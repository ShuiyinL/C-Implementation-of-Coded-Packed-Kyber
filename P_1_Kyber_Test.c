/*
 ============================================================================
 Name        : P_Kyber_Test.c
 Debugger    : Arm FVP (installed with Arm DS) with MPS2_Cortex_M4
 Author      : 
 Version     : 1
 Copyright   : Free
 Description : Implementation of Coded/Uncoded P-Kyber with MMSE/Kyber Quantization

Notes:
*The code is based on the official Kyber reference implementation:
**https://github.com/pq-crystals/kyber

*P_Kyber_Test.c: this main file contains all sub-functions used in P_Kyber PKE and KEM.
**Extra global parameters are defined in params.h

*randombytes.c: Because FVP runs on bare-metal or an undefined OS, randombytes.c currently uses a deterministic test seed for testing only.
**A secure seed source must be used when available.

 ============================================================================
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h> // Required for memcpy()
#include <stdint.h> // Required for uint8_t
#include <stddef.h>
#include <string.h>
#include <math.h> // Required for fabs()


#include "params.h"
#include "indcpa.h"
#include "kem.h"


#include "poly.h"
#include "polyvec.h"
#include "poly.h"
#include "ntt.h"
#include "reduce.h"

#include "verify.h"
#include "symmetric.h"
#include "randombytes.h"

///////////////////////////////////  CPU clock cycle count  ////////////////////////////////
volatile unsigned int *DWT_CYCCNT   = (volatile unsigned int *)0xE0001004; //address of the register
volatile unsigned int *DWT_CONTROL  = (volatile unsigned int *)0xE0001000; //address of the register
volatile unsigned int *DWT_LAR      = (volatile unsigned int *)0xE0001FB0; //address of the register
volatile unsigned int *SCB_DEMCR    = (volatile unsigned int *)0xE000EDFC; //address of the register


///////////////////////////// MMSE Quantization Codebook ////////////////////////////////
//Each ciphertext coefficient in [-1664, 1664] is mapped to the nearest value in the chosen MMSE quantization codebook.
const float codebook_d11[2048] = {-1663.50, -1661.50, -1660.00, -1658.50, -1656.50, -1655.00, -1653.50, -1651.50, -1650.00, -1648.50, -1647.00, -1645.50, -1643.50, -1642.00, -1640.50, -1638.50, -1637.00, -1635.50, -1634.00, -1632.50, -1630.50, -1629.00, -1627.50, -1625.50, -1624.00, -1622.50, -1621.00, -1619.50, -1617.50, -1616.00, -1614.50, -1612.50, -1611.00, -1609.50, -1608.00, -1606.50, -1604.50, -1603.00, -1601.50, -1599.50, -1598.00, -1596.50, -1595.00, -1593.50, -1591.50, -1590.00, -1588.50, -1586.50, -1585.00, -1583.50, -1582.00, -1580.50, -1578.50, -1577.00, -1575.50, -1573.50, -1572.00, -1570.50, -1569.00, -1567.50, -1565.50, -1564.00, -1562.50, -1560.50, -1559.00, -1557.50, -1556.00, -1554.50, -1552.50, -1551.00, -1549.50, -1547.50, -1546.00, -1544.50, -1543.00, -1541.50, -1539.50, -1538.00, -1536.50, -1534.50, -1533.00, -1531.50, -1530.00, -1528.50, -1526.50, -1525.00, -1523.50, -1521.50, -1520.00, -1518.50, -1517.00, -1515.50, -1513.50, -1512.00, -1510.50, -1508.50, -1507.00, -1505.50, -1504.00, -1502.50, -1500.50, -1499.00, -1497.50, -1495.50, -1494.00, -1492.50, -1491.00, -1489.50, -1487.50, -1486.00, -1484.50, -1482.50, -1481.00, -1479.50, -1478.00, -1476.50, -1474.50, -1473.00, -1471.50, -1469.50, -1468.00, -1466.50, -1465.00, -1463.50, -1461.50, -1460.00, -1458.50, -1456.50, -1455.00, -1453.50, -1452.00, -1450.50, -1448.50, -1447.00, -1445.50, -1443.50, -1442.00, -1440.50, -1439.00, -1437.50, -1435.50, -1434.00, -1432.50, -1430.50, -1429.00, -1427.50, -1426.00, -1424.50, -1422.50, -1421.00, -1419.50, -1417.50, -1416.00, -1414.50, -1413.00, -1411.50, -1409.50, -1408.00, -1406.50, -1404.50, -1403.00, -1401.50, -1400.00, -1398.50, -1396.50, -1395.00, -1393.50, -1391.50, -1390.00, -1388.50, -1387.00, -1385.50, -1383.50, -1382.00, -1380.50, -1378.50, -1377.00, -1375.50, -1374.00, -1372.50, -1370.50, -1369.00, -1367.50, -1365.50, -1364.00, -1362.50, -1361.00, -1359.50, -1357.50, -1356.00, -1354.50, -1352.50, -1351.00, -1349.50, -1348.00, -1346.50, -1344.50, -1343.00, -1341.50, -1339.50, -1338.00, -1336.50, -1335.00, -1333.50, -1331.50, -1330.00, -1328.50, -1326.50, -1325.00, -1323.50, -1322.00, -1320.50, -1318.50, -1317.00, -1315.50, -1313.50, -1312.00, -1310.50, -1309.00, -1307.50, -1305.50, -1304.00, -1302.50, -1300.50, -1299.00, -1297.50, -1296.00, -1294.50, -1292.50, -1291.00, -1289.50, -1287.50, -1286.00, -1284.50, -1283.00, -1281.50, -1279.50, -1278.00, -1276.50, -1274.50, -1273.00, -1271.50, -1270.00, -1268.50, -1266.50, -1265.00, -1263.50, -1261.50, -1260.00, -1258.50, -1257.00, -1255.50, -1253.50, -1252.00, -1250.50, -1248.50, -1247.00, -1245.50, -1244.00, -1242.50, -1240.50, -1239.00, -1237.50, -1235.50, -1234.00, -1232.50, -1231.00, -1229.50, -1227.50, -1226.00, -1224.50, -1222.50, -1221.00, -1219.50, -1218.00, -1216.50, -1214.50, -1213.00, -1211.50, -1209.50, -1208.00, -1206.50, -1205.00, -1203.50, -1201.50, -1200.00, -1198.50, -1196.50, -1195.00, -1193.50, -1192.00, -1190.50, -1188.50, -1187.00, -1185.50, -1183.50, -1182.00, -1180.50, -1179.00, -1177.50, -1175.50, -1174.00, -1172.50, -1170.50, -1169.00, -1167.50, -1166.00, -1164.50, -1162.50, -1161.00, -1159.50, -1157.50, -1156.00, -1154.50, -1153.00, -1151.50, -1149.50, -1148.00, -1146.50, -1144.50, -1143.00, -1141.50, -1140.00, -1138.50, -1136.50, -1135.00, -1133.50, -1131.50, -1130.00, -1128.50, -1127.00, -1125.50, -1123.50, -1122.00, -1120.50, -1118.50, -1117.00, -1115.50, -1114.00, -1112.50, -1110.50, -1109.00, -1107.50, -1105.50, -1104.00, -1102.50, -1101.00, -1099.50, -1097.50, -1096.00, -1094.50, -1092.50, -1091.00, -1089.50, -1088.00, -1086.50, -1084.50, -1083.00, -1081.50, -1079.50, -1078.00, -1076.50, -1075.00, -1073.50, -1071.50, -1070.00, -1068.50, -1066.50, -1065.00, -1063.50, -1062.00, -1060.50, -1058.50, -1057.00, -1055.50, -1053.50, -1052.00, -1050.50, -1049.00, -1047.50, -1045.50, -1044.00, -1042.50, -1040.50, -1039.00, -1037.50, -1036.00, -1034.50, -1032.50, -1031.00, -1029.50, -1027.50, -1026.00, -1024.50, -1023.00, -1021.50, -1019.50, -1018.00, -1016.50, -1014.50, -1013.00, -1011.50, -1010.00, -1008.50, -1006.50, -1005.00, -1003.50, -1001.50, -1000.00, -998.50, -997.00, -995.50, -993.50, -992.00, -990.50, -988.50, -987.00, -985.50, -984.00, -982.50, -980.50, -979.00, -977.50, -975.50, -974.00, -972.50, -971.00, -969.50, -967.50, -966.00, -964.50, -962.50, -961.00, -959.50, -958.00, -956.50, -954.50, -953.00, -951.50, -949.50, -948.00, -946.50, -945.00, -943.50, -941.50, -940.00, -938.50, -936.50, -935.00, -933.50, -932.00, -930.50, -928.50, -927.00, -925.50, -923.50, -922.00, -920.50, -919.00, -917.50, -915.50, -914.00, -912.50, -910.50, -909.00, -907.50, -906.00, -904.50, -902.50, -901.00, -899.50, -897.50, -896.00, -894.50, -893.00, -891.50, -889.50, -888.00, -886.50, -884.50, -883.00, -881.50, -880.00, -878.50, -876.50, -875.00, -873.50, -871.50, -870.00, -868.50, -867.00, -865.50, -863.50, -862.00, -860.50, -858.50, -857.00, -855.50, -854.00, -852.50, -850.50, -849.00, -847.50, -845.50, -844.00, -842.50, -841.00, -839.50, -837.50, -836.00, -834.50, -832.50, -831.00, -829.50, -828.00, -826.50, -824.50, -823.00, -821.50, -819.50, -818.00, -816.50, -815.00, -813.50, -811.50, -810.00, -808.50, -806.50, -805.00, -803.50, -802.00, -800.50, -798.50, -797.00, -795.50, -793.50, -792.00, -790.50, -789.00, -787.50, -785.50, -784.00, -782.50, -780.50, -779.00, -777.50, -776.00, -774.50, -772.50, -771.00, -769.50, -767.50, -766.00, -764.50, -763.00, -761.50, -759.50, -758.00, -756.50, -754.50, -753.00, -751.50, -750.00, -748.50, -746.50, -745.00, -743.50, -741.50, -740.00, -738.50, -737.00, -735.50, -733.50, -732.00, -730.50, -728.50, -727.00, -725.50, -724.00, -722.50, -720.50, -719.00, -717.50, -715.50, -714.00, -712.50, -711.00, -709.50, -707.50, -706.00, -704.50, -702.50, -701.00, -699.50, -698.00, -696.50, -694.50, -693.00, -691.50, -689.50, -688.00, -686.50, -685.00, -683.50, -681.50, -680.00, -678.50, -676.50, -675.00, -673.50, -672.00, -670.50, -668.50, -667.00, -665.50, -663.50, -662.00, -660.50, -659.00, -657.50, -655.50, -654.00, -652.50, -650.50, -649.00, -647.50, -646.00, -644.50, -642.50, -641.00, -639.50, -637.50, -636.00, -634.50, -633.00, -631.50, -629.50, -628.00, -626.50, -624.50, -623.00, -621.50, -620.00, -618.50, -616.50, -615.00, -613.50, -611.50, -610.00, -608.50, -607.00, -605.50, -603.50, -602.00, -600.50, -598.50, -597.00, -595.50, -594.00, -592.50, -590.50, -589.00, -587.50, -585.50, -584.00, -582.50, -581.00, -579.50, -577.50, -576.00, -574.50, -572.50, -571.00, -569.50, -568.00, -566.50, -564.50, -563.00, -561.50, -559.50, -558.00, -556.50, -555.00, -553.50, -551.50, -550.00, -548.50, -546.50, -545.00, -543.50, -542.00, -540.50, -538.50, -537.00, -535.50, -533.50, -532.00, -530.50, -529.00, -527.50, -525.50, -524.00, -522.50, -520.50, -519.00, -517.50, -516.00, -514.50, -512.50, -511.00, -509.50, -507.50, -506.00, -504.50, -503.00, -501.50, -499.50, -498.00, -496.50, -494.50, -493.00, -491.50, -490.00, -488.50, -486.50, -485.00, -483.50, -481.50, -480.00, -478.50, -477.00, -475.50, -473.50, -472.00, -470.50, -468.50, -467.00, -465.50, -464.00, -462.50, -460.50, -459.00, -457.50, -455.50, -454.00, -452.50, -451.00, -449.50, -447.50, -446.00, -444.50, -442.50, -441.00, -439.50, -438.00, -436.50, -434.50, -433.00, -431.50, -429.50, -428.00, -426.50, -425.00, -423.50, -421.50, -420.00, -418.50, -416.50, -415.00, -413.50, -412.00, -410.50, -408.50, -407.00, -405.50, -403.50, -402.00, -400.50, -399.00, -397.50, -395.50, -394.00, -392.50, -390.50, -389.00, -387.50, -386.00, -384.50, -382.50, -381.00, -379.50, -377.50, -376.00, -374.50, -373.00, -371.50, -369.50, -368.00, -366.50, -364.50, -363.00, -361.50, -360.00, -358.50, -356.50, -355.00, -353.50, -351.50, -350.00, -348.50, -347.00, -345.50, -343.50, -342.00, -340.50, -338.50, -337.00, -335.50, -334.00, -332.50, -330.50, -329.00, -327.50, -325.50, -324.00, -322.50, -321.00, -319.50, -317.50, -316.00, -314.50, -312.50, -311.00, -309.50, -308.00, -306.50, -304.50, -303.00, -301.50, -299.50, -298.00, -296.50, -295.00, -293.50, -291.50, -290.00, -288.50, -286.50, -285.00, -283.50, -282.00, -280.50, -278.50, -277.00, -275.50, -273.50, -272.00, -270.50, -269.00, -267.50, -265.50, -264.00, -262.50, -260.50, -259.00, -257.50, -256.00, -254.50, -252.50, -251.00, -249.50, -247.50, -246.00, -244.50, -243.00, -241.50, -239.50, -238.00, -236.50, -234.50, -233.00, -231.50, -230.00, -228.50, -226.50, -225.00, -223.50, -221.50, -220.00, -218.50, -217.00, -215.50, -213.50, -212.00, -210.50, -208.50, -207.00, -205.50, -204.00, -202.50, -200.50, -199.00, -197.50, -195.50, -194.00, -192.50, -191.00, -189.50, -187.50, -186.00, -184.50, -182.50, -181.00, -179.50, -178.00, -176.50, -174.50, -173.00, -171.50, -169.50, -168.00, -166.50, -165.00, -163.50, -161.50, -160.00, -158.50, -156.50, -155.00, -153.50, -152.00, -150.50, -148.50, -147.00, -145.50, -143.50, -142.00, -140.50, -139.00, -137.50, -135.50, -134.00, -132.50, -130.50, -129.00, -127.50, -126.00, -124.50, -122.50, -121.00, -119.50, -117.50, -116.00, -114.50, -113.00, -111.50, -109.50, -108.00, -106.50, -104.50, -103.00, -101.50, -100.00, -98.50, -96.50, -95.00, -93.50, -91.50, -90.00, -88.50, -87.00, -85.50, -83.50, -82.00, -80.50, -78.50, -77.00, -75.50, -74.00, -72.50, -70.50, -69.00, -67.50, -65.50, -64.00, -62.50, -61.00, -59.50, -57.50, -56.00, -54.50, -52.50, -51.00, -49.50, -48.00, -46.50, -44.50, -43.00, -41.50, -39.50, -38.00, -36.50, -35.00, -33.50, -31.50, -30.00, -28.50, -26.50, -25.00, -23.50, -22.00, -20.50, -18.50, -17.00, -15.50, -13.50, -12.00, -10.50, -9.00, -7.50, -5.50, -4.00, -2.50, -0.50, 1.00, 2.50, 4.00, 5.50, 7.50, 9.00, 10.50, 12.50, 14.00, 15.50, 17.00, 18.50, 20.50, 22.00, 23.50, 25.50, 27.00, 28.50, 30.00, 31.50, 33.50, 35.00, 36.50, 38.50, 40.00, 41.50, 43.00, 44.50, 46.50, 48.00, 49.50, 51.50, 53.00, 54.50, 56.00, 57.50, 59.50, 61.00, 62.50, 64.50, 66.00, 67.50, 69.00, 70.50, 72.50, 74.00, 75.50, 77.50, 79.00, 80.50, 82.00, 83.50, 85.50, 87.00, 88.50, 90.50, 92.00, 93.50, 95.00, 96.50, 98.50, 100.00, 101.50, 103.50, 105.00, 106.50, 108.00, 109.50, 111.50, 113.00, 114.50, 116.50, 118.00, 119.50, 121.00, 122.50, 124.50, 126.00, 127.50, 129.50, 131.00, 132.50, 134.00, 135.50, 137.50, 139.00, 140.50, 142.50, 144.00, 145.50, 147.00, 148.50, 150.50, 152.00, 153.50, 155.50, 157.00, 158.50, 160.00, 161.50, 163.50, 165.00, 166.50, 168.50, 170.00, 171.50, 173.00, 174.50, 176.50, 178.00, 179.50, 181.50, 183.00, 184.50, 186.00, 187.50, 189.50, 191.00, 192.50, 194.50, 196.00, 197.50, 199.00, 200.50, 202.50, 204.00, 205.50, 207.50, 209.00, 210.50, 212.00, 213.50, 215.50, 217.00, 218.50, 220.50, 222.00, 223.50, 225.00, 226.50, 228.50, 230.00, 231.50, 233.50, 235.00, 236.50, 238.00, 239.50, 241.50, 243.00, 244.50, 246.50, 248.00, 249.50, 251.00, 252.50, 254.50, 256.00, 257.50, 259.50, 261.00, 262.50, 264.00, 265.50, 267.50, 269.00, 270.50, 272.50, 274.00, 275.50, 277.00, 278.50, 280.50, 282.00, 283.50, 285.50, 287.00, 288.50, 290.00, 291.50, 293.50, 295.00, 296.50, 298.50, 300.00, 301.50, 303.00, 304.50, 306.50, 308.00, 309.50, 311.50, 313.00, 314.50, 316.00, 317.50, 319.50, 321.00, 322.50, 324.50, 326.00, 327.50, 329.00, 330.50, 332.50, 334.00, 335.50, 337.50, 339.00, 340.50, 342.00, 343.50, 345.50, 347.00, 348.50, 350.50, 352.00, 353.50, 355.00, 356.50, 358.50, 360.00, 361.50, 363.50, 365.00, 366.50, 368.00, 369.50, 371.50, 373.00, 374.50, 376.50, 378.00, 379.50, 381.00, 382.50, 384.50, 386.00, 387.50, 389.50, 391.00, 392.50, 394.00, 395.50, 397.50, 399.00, 400.50, 402.50, 404.00, 405.50, 407.00, 408.50, 410.50, 412.00, 413.50, 415.50, 417.00, 418.50, 420.00, 421.50, 423.50, 425.00, 426.50, 428.50, 430.00, 431.50, 433.00, 434.50, 436.50, 438.00, 439.50, 441.50, 443.00, 444.50, 446.00, 447.50, 449.50, 451.00, 452.50, 454.50, 456.00, 457.50, 459.00, 460.50, 462.50, 464.00, 465.50, 467.50, 469.00, 470.50, 472.00, 473.50, 475.50, 477.00, 478.50, 480.50, 482.00, 483.50, 485.00, 486.50, 488.50, 490.00, 491.50, 493.50, 495.00, 496.50, 498.00, 499.50, 501.50, 503.00, 504.50, 506.50, 508.00, 509.50, 511.00, 512.50, 514.50, 516.00, 517.50, 519.50, 521.00, 522.50, 524.00, 525.50, 527.50, 529.00, 530.50, 532.50, 534.00, 535.50, 537.00, 538.50, 540.50, 542.00, 543.50, 545.50, 547.00, 548.50, 550.00, 551.50, 553.50, 555.00, 556.50, 558.50, 560.00, 561.50, 563.00, 564.50, 566.50, 568.00, 569.50, 571.50, 573.00, 574.50, 576.00, 577.50, 579.50, 581.00, 582.50, 584.50, 586.00, 587.50, 589.00, 590.50, 592.50, 594.00, 595.50, 597.50, 599.00, 600.50, 602.00, 603.50, 605.50, 607.00, 608.50, 610.50, 612.00, 613.50, 615.00, 616.50, 618.50, 620.00, 621.50, 623.50, 625.00, 626.50, 628.00, 629.50, 631.50, 633.00, 634.50, 636.50, 638.00, 639.50, 641.00, 642.50, 644.50, 646.00, 647.50, 649.50, 651.00, 652.50, 654.00, 655.50, 657.50, 659.00, 660.50, 662.50, 664.00, 665.50, 667.00, 668.50, 670.50, 672.00, 673.50, 675.50, 677.00, 678.50, 680.00, 681.50, 683.50, 685.00, 686.50, 688.50, 690.00, 691.50, 693.00, 694.50, 696.50, 698.00, 699.50, 701.50, 703.00, 704.50, 706.00, 707.50, 709.50, 711.00, 712.50, 714.50, 716.00, 717.50, 719.00, 720.50, 722.50, 724.00, 725.50, 727.50, 729.00, 730.50, 732.00, 733.50, 735.50, 737.00, 738.50, 740.50, 742.00, 743.50, 745.00, 746.50, 748.50, 750.00, 751.50, 753.50, 755.00, 756.50, 758.00, 759.50, 761.50, 763.00, 764.50, 766.50, 768.00, 769.50, 771.00, 772.50, 774.50, 776.00, 777.50, 779.50, 781.00, 782.50, 784.00, 785.50, 787.50, 789.00, 790.50, 792.50, 794.00, 795.50, 797.00, 798.50, 800.50, 802.00, 803.50, 805.50, 807.00, 808.50, 810.00, 811.50, 813.50, 815.00, 816.50, 818.50, 820.00, 821.50, 823.00, 824.50, 826.50, 828.00, 829.50, 831.50, 833.00, 834.50, 836.00, 837.50, 839.50, 841.00, 842.50, 844.50, 846.00, 847.50, 849.00, 850.50, 852.50, 854.00, 855.50, 857.50, 859.00, 860.50, 862.00, 863.50, 865.50, 867.00, 868.50, 870.50, 872.00, 873.50, 875.00, 876.50, 878.50, 880.00, 881.50, 883.50, 885.00, 886.50, 888.00, 889.50, 891.50, 893.00, 894.50, 896.50, 898.00, 899.50, 901.00, 902.50, 904.50, 906.00, 907.50, 909.50, 911.00, 912.50, 914.00, 915.50, 917.50, 919.00, 920.50, 922.50, 924.00, 925.50, 927.00, 928.50, 930.50, 932.00, 933.50, 935.50, 937.00, 938.50, 940.00, 941.50, 943.50, 945.00, 946.50, 948.50, 950.00, 951.50, 953.00, 954.50, 956.50, 958.00, 959.50, 961.50, 963.00, 964.50, 966.00, 967.50, 969.50, 971.00, 972.50, 974.50, 976.00, 977.50, 979.00, 980.50, 982.50, 984.00, 985.50, 987.50, 989.00, 990.50, 992.00, 993.50, 995.50, 997.00, 998.50, 1000.50, 1002.00, 1003.50, 1005.00, 1006.50, 1008.50, 1010.00, 1011.50, 1013.50, 1015.00, 1016.50, 1018.00, 1019.50, 1021.50, 1023.00, 1024.50, 1026.50, 1028.00, 1029.50, 1031.00, 1032.50, 1034.50, 1036.00, 1037.50, 1039.50, 1041.00, 1042.50, 1044.00, 1045.50, 1047.50, 1049.00, 1050.50, 1052.50, 1054.00, 1055.50, 1057.00, 1058.50, 1060.50, 1062.00, 1063.50, 1065.50, 1067.00, 1068.50, 1070.00, 1071.50, 1073.50, 1075.00, 1076.50, 1078.50, 1080.00, 1081.50, 1083.00, 1084.50, 1086.50, 1088.00, 1089.50, 1091.50, 1093.00, 1094.50, 1096.00, 1097.50, 1099.50, 1101.00, 1102.50, 1104.50, 1106.00, 1107.50, 1109.00, 1110.50, 1112.50, 1114.00, 1115.50, 1117.50, 1119.00, 1120.50, 1122.00, 1123.50, 1125.50, 1127.00, 1128.50, 1130.50, 1132.00, 1133.50, 1135.00, 1136.50, 1138.50, 1140.00, 1141.50, 1143.50, 1145.00, 1146.50, 1148.00, 1149.50, 1151.50, 1153.00, 1154.50, 1156.50, 1158.00, 1159.50, 1161.00, 1162.50, 1164.50, 1166.00, 1167.50, 1169.50, 1171.00, 1172.50, 1174.00, 1175.50, 1177.50, 1179.00, 1180.50, 1182.50, 1184.00, 1185.50, 1187.00, 1188.50, 1190.50, 1192.00, 1193.50, 1195.50, 1197.00, 1198.50, 1200.00, 1201.50, 1203.50, 1205.00, 1206.50, 1208.50, 1210.00, 1211.50, 1213.00, 1214.50, 1216.50, 1218.00, 1219.50, 1221.50, 1223.00, 1224.50, 1226.00, 1227.50, 1229.50, 1231.00, 1232.50, 1234.50, 1236.00, 1237.50, 1239.00, 1240.50, 1242.50, 1244.00, 1245.50, 1247.50, 1249.00, 1250.50, 1252.00, 1253.50, 1255.50, 1257.00, 1258.50, 1260.50, 1262.00, 1263.50, 1265.00, 1266.50, 1268.50, 1270.00, 1271.50, 1273.50, 1275.00, 1276.50, 1278.00, 1279.50, 1281.50, 1283.00, 1284.50, 1286.50, 1288.00, 1289.50, 1291.00, 1292.50, 1294.50, 1296.00, 1297.50, 1299.50, 1301.00, 1302.50, 1304.00, 1305.50, 1307.50, 1309.00, 1310.50, 1312.50, 1314.00, 1315.50, 1317.00, 1318.50, 1320.50, 1322.00, 1323.50, 1325.50, 1327.00, 1328.50, 1330.00, 1331.50, 1333.50, 1335.00, 1336.50, 1338.50, 1340.00, 1341.50, 1343.00, 1344.50, 1346.50, 1348.00, 1349.50, 1351.50, 1353.00, 1354.50, 1356.00, 1357.50, 1359.50, 1361.00, 1362.50, 1364.50, 1366.00, 1367.50, 1369.00, 1370.50, 1372.50, 1374.00, 1375.50, 1377.50, 1379.00, 1380.50, 1382.00, 1383.50, 1385.50, 1387.00, 1388.50, 1390.50, 1392.00, 1393.50, 1395.00, 1396.50, 1398.50, 1400.00, 1401.50, 1403.50, 1405.00, 1406.50, 1408.00, 1409.50, 1411.50, 1413.00, 1414.50, 1416.50, 1418.00, 1419.50, 1421.00, 1422.50, 1424.50, 1426.00, 1427.50, 1429.50, 1431.00, 1432.50, 1434.00, 1435.50, 1437.50, 1439.00, 1440.50, 1442.50, 1444.00, 1445.50, 1447.00, 1448.50, 1450.50, 1452.00, 1453.50, 1455.50, 1457.00, 1458.50, 1460.00, 1461.50, 1463.50, 1465.00, 1466.50, 1468.50, 1470.00, 1471.50, 1473.00, 1474.50, 1476.50, 1478.00, 1479.50, 1481.50, 1483.00, 1484.50, 1486.00, 1487.50, 1489.50, 1491.00, 1492.50, 1494.50, 1496.00, 1497.50, 1499.00, 1500.50, 1502.50, 1504.00, 1505.50, 1507.50, 1509.00, 1510.50, 1512.00, 1513.50, 1515.50, 1517.00, 1518.50, 1520.50, 1522.00, 1523.50, 1525.00, 1526.50, 1528.50, 1530.00, 1531.50, 1533.50, 1535.00, 1536.50, 1538.00, 1539.50, 1541.50, 1543.00, 1544.50, 1546.50, 1548.00, 1549.50, 1551.00, 1552.50, 1554.50, 1556.00, 1557.50, 1559.50, 1561.00, 1562.50, 1564.00, 1565.50, 1567.50, 1569.00, 1570.50, 1572.50, 1574.00, 1575.50, 1577.00, 1578.50, 1580.50, 1582.00, 1583.50, 1585.50, 1587.00, 1588.50, 1590.00, 1591.50, 1593.50, 1595.00, 1596.50, 1598.50, 1600.00, 1601.50, 1603.00, 1604.50, 1606.50, 1608.00, 1609.50, 1611.50, 1613.00, 1614.50, 1616.00, 1617.50, 1619.50, 1621.00, 1622.50, 1624.50, 1626.00, 1627.50, 1629.00, 1630.50, 1632.50, 1634.00, 1635.50, 1637.50, 1639.00, 1640.50, 1642.00, 1643.50, 1645.50, 1647.00, 1648.50, 1650.50, 1652.00, 1653.50, 1655.00, 1656.50, 1658.50, 1660.00, 1661.50, 1663.50};
const float codebook_d10[1024] = {-1662.50, -1659.00, -1656.00, -1652.50, -1649.00, -1646.00, -1643.00, -1639.50, -1636.00, -1633.00, -1630.00, -1626.50, -1623.00, -1620.00, -1617.00, -1613.50, -1610.00, -1607.00, -1604.00, -1600.50, -1597.00, -1594.00, -1591.00, -1587.50, -1584.00, -1581.00, -1578.00, -1574.50, -1571.00, -1568.00, -1565.00, -1561.50, -1558.00, -1555.00, -1552.00, -1548.50, -1545.00, -1542.00, -1539.00, -1535.50, -1532.00, -1529.00, -1526.00, -1522.50, -1519.00, -1516.00, -1513.00, -1509.50, -1506.00, -1503.00, -1500.00, -1496.50, -1493.00, -1490.00, -1487.00, -1483.50, -1480.00, -1477.00, -1474.00, -1470.50, -1467.00, -1464.00, -1461.00, -1457.50, -1454.00, -1451.00, -1448.00, -1444.50, -1441.00, -1438.00, -1435.00, -1431.50, -1428.00, -1425.00, -1422.00, -1418.50, -1415.00, -1412.00, -1409.00, -1405.50, -1402.00, -1399.00, -1396.00, -1392.50, -1389.00, -1386.00, -1383.00, -1379.50, -1376.00, -1373.00, -1370.00, -1366.50, -1363.00, -1360.00, -1357.00, -1353.50, -1350.00, -1347.00, -1344.00, -1340.50, -1337.00, -1334.00, -1331.00, -1327.50, -1324.00, -1321.00, -1318.00, -1314.50, -1311.00, -1308.00, -1305.00, -1301.50, -1298.00, -1295.00, -1292.00, -1288.50, -1285.00, -1282.00, -1279.00, -1275.50, -1272.00, -1269.00, -1266.00, -1262.50, -1259.00, -1256.00, -1253.00, -1249.50, -1246.00, -1243.00, -1240.00, -1236.50, -1233.00, -1230.00, -1227.00, -1223.50, -1220.00, -1217.00, -1214.00, -1210.50, -1207.00, -1204.00, -1201.00, -1197.50, -1194.00, -1191.00, -1188.00, -1184.50, -1181.00, -1178.00, -1175.00, -1171.50, -1168.00, -1165.00, -1162.00, -1158.50, -1155.00, -1152.00, -1149.00, -1145.50, -1142.00, -1139.00, -1136.00, -1132.50, -1129.00, -1126.00, -1123.00, -1119.50, -1116.00, -1113.00, -1110.00, -1106.50, -1103.00, -1100.00, -1097.00, -1093.50, -1090.00, -1087.00, -1084.00, -1080.50, -1077.00, -1074.00, -1071.00, -1067.50, -1064.00, -1061.00, -1058.00, -1054.50, -1051.00, -1048.00, -1045.00, -1041.50, -1038.00, -1035.00, -1032.00, -1028.50, -1025.00, -1022.00, -1019.00, -1015.50, -1012.00, -1009.00, -1006.00, -1002.50, -999.00, -996.00, -993.00, -989.50, -986.00, -983.00, -980.00, -976.50, -973.00, -970.00, -967.00, -963.50, -960.00, -957.00, -954.00, -950.50, -947.00, -944.00, -941.00, -937.50, -934.00, -931.00, -928.00, -924.50, -921.00, -918.00, -915.00, -911.50, -908.00, -905.00, -902.00, -898.50, -895.00, -892.00, -889.00, -885.50, -882.00, -879.00, -876.00, -872.50, -869.00, -866.00, -863.00, -859.50, -856.00, -853.00, -850.00, -846.50, -843.00, -840.00, -837.00, -833.50, -830.00, -827.00, -824.00, -820.50, -817.00, -814.00, -811.00, -807.50, -804.00, -801.00, -798.00, -794.50, -791.00, -788.00, -785.00, -781.50, -778.00, -775.00, -772.00, -768.50, -765.00, -762.00, -759.00, -755.50, -752.00, -749.00, -746.00, -742.50, -739.00, -736.00, -733.00, -729.50, -726.00, -723.00, -720.00, -716.50, -713.00, -710.00, -707.00, -703.50, -700.00, -697.00, -694.00, -690.50, -687.00, -684.00, -681.00, -677.50, -674.00, -671.00, -668.00, -664.50, -661.00, -658.00, -655.00, -651.50, -648.00, -645.00, -642.00, -638.50, -635.00, -632.00, -629.00, -625.50, -622.00, -619.00, -616.00, -612.50, -609.00, -606.00, -603.00, -599.50, -596.00, -593.00, -590.00, -586.50, -583.00, -580.00, -577.00, -573.50, -570.00, -567.00, -564.00, -560.50, -557.00, -554.00, -551.00, -547.50, -544.00, -541.00, -538.00, -534.50, -531.00, -528.00, -525.00, -521.50, -518.00, -515.00, -512.00, -508.50, -505.00, -502.00, -499.00, -495.50, -492.00, -489.00, -486.00, -482.50, -479.00, -476.00, -473.00, -469.50, -466.00, -463.00, -460.00, -456.50, -453.00, -450.00, -447.00, -443.50, -440.00, -437.00, -434.00, -430.50, -427.00, -424.00, -421.00, -417.50, -414.00, -411.00, -408.00, -404.50, -401.00, -398.00, -395.00, -391.50, -388.00, -385.00, -382.00, -378.50, -375.00, -372.00, -369.00, -365.50, -362.00, -359.00, -356.00, -352.50, -349.00, -346.00, -343.00, -339.50, -336.00, -333.00, -330.00, -326.50, -323.00, -320.00, -317.00, -313.50, -310.00, -307.00, -304.00, -300.50, -297.00, -294.00, -291.00, -287.50, -284.00, -281.00, -278.00, -274.50, -271.00, -268.00, -265.00, -261.50, -258.00, -255.00, -252.00, -248.50, -245.00, -242.00, -239.00, -235.50, -232.00, -229.00, -226.00, -222.50, -219.00, -216.00, -213.00, -209.50, -206.00, -203.00, -200.00, -196.50, -193.00, -190.00, -187.00, -183.50, -180.00, -177.00, -174.00, -170.50, -167.00, -164.00, -161.00, -157.50, -154.00, -151.00, -148.00, -144.50, -141.00, -138.00, -135.00, -131.50, -128.00, -125.00, -122.00, -118.50, -115.00, -112.00, -109.00, -105.50, -102.00, -99.00, -96.00, -92.50, -89.00, -86.00, -83.00, -79.50, -76.00, -73.00, -70.00, -66.50, -63.00, -60.00, -57.00, -53.50, -50.00, -47.00, -44.00, -40.50, -37.00, -34.00, -31.00, -27.50, -24.00, -21.00, -18.00, -14.50, -11.00, -8.00, -5.00, -1.50, 2.00, 5.00, 8.00, 11.50, 15.00, 18.00, 21.00, 24.50, 28.00, 31.00, 34.00, 37.50, 41.00, 44.00, 47.00, 50.50, 54.00, 57.00, 60.00, 63.50, 67.00, 70.00, 73.00, 76.50, 80.00, 83.00, 86.00, 89.50, 93.00, 96.00, 99.00, 102.50, 106.00, 109.00, 112.00, 115.50, 119.00, 122.00, 125.00, 128.50, 132.00, 135.00, 138.00, 141.50, 145.00, 148.00, 151.00, 154.50, 158.00, 161.00, 164.00, 167.50, 171.00, 174.00, 177.00, 180.50, 184.00, 187.00, 190.00, 193.50, 197.00, 200.00, 203.00, 206.50, 210.00, 213.00, 216.00, 219.50, 223.00, 226.00, 229.00, 232.50, 236.00, 239.00, 242.00, 245.50, 249.00, 252.00, 255.00, 258.50, 262.00, 265.00, 268.00, 271.50, 275.00, 278.00, 281.00, 284.50, 288.00, 291.00, 294.00, 297.50, 301.00, 304.00, 307.00, 310.50, 314.00, 317.00, 320.00, 323.50, 327.00, 330.00, 333.00, 336.50, 340.00, 343.00, 346.00, 349.50, 353.00, 356.00, 359.00, 362.50, 366.00, 369.00, 372.00, 375.50, 379.00, 382.00, 385.00, 388.50, 392.00, 395.00, 398.00, 401.50, 405.00, 408.00, 411.00, 414.50, 418.00, 421.00, 424.00, 427.50, 431.00, 434.00, 437.00, 440.50, 444.00, 447.00, 450.00, 453.50, 457.00, 460.00, 463.00, 466.50, 470.00, 473.00, 476.00, 479.50, 483.00, 486.00, 489.00, 492.50, 496.00, 499.00, 502.00, 505.50, 509.00, 512.00, 515.00, 518.50, 522.00, 525.00, 528.00, 531.50, 535.00, 538.00, 541.00, 544.50, 548.00, 551.00, 554.00, 557.50, 561.00, 564.00, 567.00, 570.50, 574.00, 577.00, 580.00, 583.50, 587.00, 590.00, 593.00, 596.50, 600.00, 603.00, 606.00, 609.50, 613.00, 616.00, 619.00, 622.50, 626.00, 629.00, 632.00, 635.50, 639.00, 642.00, 645.00, 648.50, 652.00, 655.00, 658.00, 661.50, 665.00, 668.00, 671.00, 674.50, 678.00, 681.00, 684.00, 687.50, 691.00, 694.00, 697.00, 700.50, 704.00, 707.00, 710.00, 713.50, 717.00, 720.00, 723.00, 726.50, 730.00, 733.00, 736.00, 739.50, 743.00, 746.00, 749.00, 752.50, 756.00, 759.00, 762.00, 765.50, 769.00, 772.00, 775.00, 778.50, 782.00, 785.00, 788.00, 791.50, 795.00, 798.00, 801.00, 804.50, 808.00, 811.00, 814.00, 817.50, 821.00, 824.00, 827.00, 830.50, 834.00, 837.00, 840.00, 843.50, 847.00, 850.00, 853.00, 856.50, 860.00, 863.00, 866.00, 869.50, 873.00, 876.00, 879.00, 882.50, 886.00, 889.00, 892.00, 895.50, 899.00, 902.00, 905.00, 908.50, 912.00, 915.00, 918.00, 921.50, 925.00, 928.00, 931.00, 934.50, 938.00, 941.00, 944.00, 947.50, 951.00, 954.00, 957.00, 960.50, 964.00, 967.00, 970.00, 973.50, 977.00, 980.00, 983.00, 986.50, 990.00, 993.00, 996.00, 999.50, 1003.00, 1006.00, 1009.00, 1012.50, 1016.00, 1019.00, 1022.00, 1025.50, 1029.00, 1032.00, 1035.00, 1038.50, 1042.00, 1045.00, 1048.00, 1051.50, 1055.00, 1058.00, 1061.00, 1064.50, 1068.00, 1071.00, 1074.00, 1077.50, 1081.00, 1084.00, 1087.00, 1090.50, 1094.00, 1097.00, 1100.00, 1103.50, 1107.00, 1110.00, 1113.00, 1116.50, 1120.00, 1123.00, 1126.00, 1129.50, 1133.00, 1136.00, 1139.00, 1142.50, 1146.00, 1149.00, 1152.00, 1155.50, 1159.00, 1162.00, 1165.00, 1168.50, 1172.00, 1175.00, 1178.00, 1181.50, 1185.00, 1188.00, 1191.00, 1194.50, 1198.00, 1201.00, 1204.00, 1207.50, 1211.00, 1214.00, 1217.00, 1220.50, 1224.00, 1227.00, 1230.00, 1233.50, 1237.00, 1240.00, 1243.00, 1246.50, 1250.00, 1253.00, 1256.00, 1259.50, 1263.00, 1266.00, 1269.00, 1272.50, 1276.00, 1279.00, 1282.00, 1285.50, 1289.00, 1292.00, 1295.00, 1298.50, 1302.00, 1305.00, 1308.00, 1311.50, 1315.00, 1318.00, 1321.00, 1324.50, 1328.00, 1331.00, 1334.00, 1337.50, 1341.00, 1344.00, 1347.00, 1350.50, 1354.00, 1357.00, 1360.00, 1363.50, 1367.00, 1370.00, 1373.00, 1376.50, 1380.00, 1383.00, 1386.00, 1389.50, 1393.00, 1396.00, 1399.00, 1402.50, 1406.00, 1409.00, 1412.00, 1415.50, 1419.00, 1422.00, 1425.00, 1428.50, 1432.00, 1435.00, 1438.00, 1441.50, 1445.00, 1448.00, 1451.00, 1454.50, 1458.00, 1461.00, 1464.00, 1467.50, 1471.00, 1474.00, 1477.00, 1480.50, 1484.00, 1487.00, 1490.00, 1493.50, 1497.00, 1500.00, 1503.00, 1506.50, 1510.00, 1513.00, 1516.00, 1519.50, 1523.00, 1526.00, 1529.00, 1532.50, 1536.00, 1539.00, 1542.00, 1545.50, 1549.00, 1552.00, 1555.00, 1558.50, 1562.00, 1565.00, 1568.00, 1571.50, 1575.00, 1578.00, 1581.00, 1584.50, 1588.00, 1591.00, 1594.00, 1597.50, 1601.00, 1604.00, 1607.00, 1610.50, 1614.00, 1617.00, 1620.00, 1623.50, 1627.00, 1630.00, 1633.00, 1636.50, 1640.00, 1643.00, 1646.00, 1649.50, 1653.00, 1656.00, 1659.00, 1662.50};
const float codebook_d5[32]={-1612.00, -1507.50, -1403.50, -1299.50, -1195.50, -1091.50, -987.50, -883.50, -779.50, -675.50, -571.50, -467.50, -363.50, -259.50, -155.50, -51.50, 52.50, 156.50, 260.50, 364.50, 468.50, 572.50, 676.50, 780.50, 884.50, 988.50, 1092.50, 1196.50, 1300.50, 1404.50, 1508.50, 1612.50};
const float codebook_d4[16]={-1560.00, -1351.50, -1143.50, -935.50, -727.50, -519.50, -311.50, -103.50, 104.50, 312.50, 520.50, 728.50, 936.50, 1144.50, 1352.50, 1560.50};


///////////////////////////////////////////////////// Fast Round ////////////////////////////////////////////////////////////////////////
static inline int16_t fast_roundf(float f) {
    return (int16_t)(f >= 0.0f ? f + 0.5f : f - 0.5f);
}


///////////////////////////////////////////////////// Print functions start ////////////////////////////////////////////////////////////////////////
// Output functions for debugging purposes
void printUint8Array(const uint8_t* arr, size_t size) {
    printf("Array Elements (Decimal): ");


    for (size_t i = 0; i < size; i++) {
        printf("%u ", arr[i]); // Print as unsigned decimal integer
    }
    printf("\n");

}


void printint16Array(const int16_t* arr, size_t size) {
    printf("Array Elements (Decimal): ");


    for (size_t i = 0; i < size; i++) {
        printf("%d ", arr[i]); // Print as unsigned decimal integer
    }
    printf("\n");

}

void printFloatArray(float arr[], int size) {
    printf("Elements of the array: ");
    for (int i = 0; i < size; i++) {
        printf("%.2f ", arr[i]); // Prints each float with 2 decimal places
    }
    printf("\n"); // Prints a newline character at the end
}


void printIntArray(int arr[], int size) {
    printf("Array elements: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");


}

///////////////////////////////////////////////////// Print functions end ////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////// Kyber PKE with MMSE Quantization Start ////////////////////////////////////////////////////////////////////////


typedef struct {
    float element;
    int index;
} ClosestResult;


ClosestResult findClosestInSortedFloatArray(const float arr[], int n, int16_t target) {
    ClosestResult result;

    // Handle boundaries quickly
    if (target <= arr[0]) {
        result.element = arr[0];
        result.index = 0;
        return result;
    }
    if (target >= arr[n - 1]) {
        result.element = arr[n - 1];
        result.index = n - 1;
        return result;
    }

    // Binary search to find the insertion point
    int low = 0, high = n - 1;
    while (low < high) {
        int mid = (low + high) >> 1;
        if (arr[mid] < target)
            low = mid + 1;
        else
            high = mid;
    }

    // low is the index of the first element >= target
    int idx2 = low;       // candidate on the right
    int idx1 = low - 1;   // candidate on the left

    // Compare which is closer
    float diff1 = target - arr[idx1];
    if (diff1 < 0) diff1 = -diff1;
    float diff2 = arr[idx2] - target;
    if (diff2 < 0) diff2 = -diff2;

    if (diff1 <= diff2) {
        result.element = arr[idx1];
        result.index = idx1;
    }
    else {
        result.element = arr[idx2];
        result.index = idx2;
    }

    return result;
}




static void unpack_pk(polyvec* pk,
    uint8_t seed[KYBER_SYMBYTES],
    const uint8_t packedpk[KYBER_INDCPA_PUBLICKEYBYTES])
{
    size_t i;
    polyvec_frombytes(pk, packedpk);
    for (i = 0; i < KYBER_SYMBYTES; i++)
        seed[i] = packedpk[i + KYBER_POLYVECBYTES];
}



static void unpack_sk(polyvec* sk, const uint8_t packedsk[KYBER_INDCPA_SECRETKEYBYTES])
{
    polyvec_frombytes(sk, packedsk);
}


void polyvec_b_mmseq_pack(uint8_t r[KYBER_POLYVECCOMPRESSEDBYTES], const polyvec* a)
{
    uint16_t t[4];
    unsigned int i, j, k;

    for (i = 0; i < KYBER_K; i++) {
        for (j = 0; j < KYBER_N / 4; j++) {
            for (k = 0; k < 4; k++) {
                t[k] = a->vec[i].coeffs[4 * j + k];
                t[k] += ((int16_t)t[k] >> 15)& KYBER_Q;
            }

            r[0] = (t[0] >> 0);
            r[1] = (t[0] >> 8) | (t[1] << 2);
            r[2] = (t[1] >> 6) | (t[2] << 4);
            r[3] = (t[2] >> 4) | (t[3] << 6);
            r[4] = (t[3] >> 2);
            r += 5;
        }
    }
}


void polyvec_decompress_mmse(polyvec* r, const uint8_t a[KYBER_POLYVECCOMPRESSEDBYTES])
{
    unsigned int i, j, k;

#if (KYBER_POLYVECCOMPRESSEDBYTES == (KYBER_K * 352))
    uint16_t t[8];
    for (i = 0; i < KYBER_K; i++) {
        for (j = 0; j < KYBER_N / 8; j++) {

            r->vec[i].coeffs[8 * j + 0] = ((a[0] >> 0) | ((uint16_t)a[1] << 8)) & 0x7FF;
            r->vec[i].coeffs[8 * j + 1] = ((a[1] >> 3) | ((uint16_t)a[2] << 5)) & 0x7FF;
            r->vec[i].coeffs[8 * j + 2] = ((a[2] >> 6) | ((uint16_t)a[3] << 2) | ((uint16_t)a[4] << 10)) & 0x7FF;
            r->vec[i].coeffs[8 * j + 3] = ((a[4] >> 1) | ((uint16_t)a[5] << 7)) & 0x7FF;
            r->vec[i].coeffs[8 * j + 4] = ((a[5] >> 4) | ((uint16_t)a[6] << 4)) & 0x7FF;
            r->vec[i].coeffs[8 * j + 5] = ((a[6] >> 7) | ((uint16_t)a[7] << 1) | ((uint16_t)a[8] << 9)) & 0x7FF;
            r->vec[i].coeffs[8 * j + 6] = ((a[8] >> 2) | ((uint16_t)a[9] << 6)) & 0x7FF;
            r->vec[i].coeffs[8 * j + 7] = ((a[9] >> 5) | ((uint16_t)a[10] << 3)) & 0x7FF;
            a += 11;

        }
    }
#elif (KYBER_POLYVECCOMPRESSEDBYTES == (KYBER_K * 320))
    for (i = 0; i < KYBER_K; i++) {
        for (j = 0; j < KYBER_N / 4; j++) {
            r->vec[i].coeffs[4 * j + 0] = ((a[0] >> 0) | ((uint16_t)a[1] << 8)) & 0x3FF;
            r->vec[i].coeffs[4 * j + 1] = ((a[1] >> 2) | ((uint16_t)a[2] << 6)) & 0x3FF;
            r->vec[i].coeffs[4 * j + 2] = ((a[2] >> 4) | ((uint16_t)a[3] << 4)) & 0x3FF;
            r->vec[i].coeffs[4 * j + 3] = ((a[3] >> 6) | ((uint16_t)a[4] << 2)) & 0x3FF;
            a += 5;

        }
    }
#else
#error "KYBER_POLYVECCOMPRESSEDBYTES needs to be in {320*KYBER_K, 352*KYBER_K}"
#endif
}


void polyvec_compress_mmse(uint8_t r[KYBER_POLYVECCOMPRESSEDBYTES], const polyvec* a)
{
    unsigned int i, j, k;

#if (KYBER_POLYVECCOMPRESSEDBYTES == (KYBER_K * 352))
    uint16_t t[8];

    const float *codebook = codebook_d11;
    int num_floats=2048;

    ClosestResult found;


    for (i = 0; i < KYBER_K; i++) {
        for (j = 0; j < KYBER_N / 8; j++) {
            for (k = 0; k < 8; k++) {
                found = findClosestInSortedFloatArray(codebook, num_floats, a->vec[i].coeffs[8 * j + k]);
                t[k] = (int16_t)found.index;

            }

            r[0] = (t[0] >> 0);
            r[1] = (t[0] >> 8) | (t[1] << 3);
            r[2] = (t[1] >> 5) | (t[2] << 6);
            r[3] = (t[2] >> 2);
            r[4] = (t[2] >> 10) | (t[3] << 1);
            r[5] = (t[3] >> 7) | (t[4] << 4);
            r[6] = (t[4] >> 4) | (t[5] << 7);
            r[7] = (t[5] >> 1);
            r[8] = (t[5] >> 9) | (t[6] << 2);
            r[9] = (t[6] >> 6) | (t[7] << 5);
            r[10] = (t[7] >> 3);
            r += 11;
        }
    }
#elif (KYBER_POLYVECCOMPRESSEDBYTES == (KYBER_K * 320))
    uint16_t t[4];


    const float *codebook = codebook_d10;
    int num_floats=1024;

    ClosestResult found;

    for (i = 0; i < KYBER_K; i++) {
        for (j = 0; j < KYBER_N / 4; j++) {
            for (k = 0; k < 4; k++) {
                found = findClosestInSortedFloatArray(codebook, num_floats, a->vec[i].coeffs[4 * j + k]);
                t[k] = (int16_t)found.index;
            }

            r[0] = (t[0] >> 0);
            r[1] = (t[0] >> 8) | (t[1] << 2);
            r[2] = (t[1] >> 6) | (t[2] << 4);
            r[3] = (t[2] >> 4) | (t[3] << 6);
            r[4] = (t[3] >> 2);
            r += 5;
        }
    }
#else
#error "KYBER_POLYVECCOMPRESSEDBYTES needs to be in {320*KYBER_K, 352*KYBER_K}"
#endif
}


void polyvec_index_toelement(polyvec* r, polyvec* e, polyvec* a)
{
    unsigned int i, j, k;

#if (KYBER_POLYVECCOMPRESSEDBYTES == (KYBER_K * 352))


    const float *codebook = codebook_d11;
    int num_floats=2048;

    for (j = 0; j < KYBER_K; j++) {
        for (i = 0; i < KYBER_N; i++) {

            //r->vec[j].coeffs[i] = round(codebook[a->vec[j].coeffs[i]]);
            r->vec[j].coeffs[i] = fast_roundf(codebook[a->vec[j].coeffs[i]]);
            e->vec[j].coeffs[i] = (int16_t)(2 * (codebook[a->vec[j].coeffs[i]] - r->vec[j].coeffs[i]));
        }
    }
#elif (KYBER_POLYVECCOMPRESSEDBYTES == (KYBER_K * 320))


    const float *codebook = codebook_d10;
    int num_floats=1024;

    for (j = 0; j < KYBER_K; j++) {
        for (i = 0; i < KYBER_N; i++) {


            r->vec[j].coeffs[i] = fast_roundf(codebook[a->vec[j].coeffs[i]]);
            e->vec[j].coeffs[i] = (int16_t)(2 * (codebook[a->vec[j].coeffs[i]] - r->vec[j].coeffs[i]));
        }
    }
#else
#error "KYBER_POLYVECCOMPRESSEDBYTES needs to be in {320*KYBER_K, 352*KYBER_K}"
#endif
}



void poly_compress_mmse(uint8_t r[KYBER_POLYCOMPRESSEDBYTES], const poly* a)
{
    unsigned int i, j;
    int16_t u;
    uint8_t t[8];

#if (KYBER_POLYCOMPRESSEDBYTES == 128)

    const float *codebook = codebook_d4;
    int num_floats=16;
    ClosestResult found;

    for (i = 0; i < KYBER_N / 8; i++) {
        for (j = 0; j < 8; j++) {
            // map to positive standard representatives
            found = findClosestInSortedFloatArray(codebook, num_floats, a->coeffs[8 * i + j]);
            t[j] = (int16_t)found.index;
        }

        r[0] = t[0] | (t[1] << 4);
        r[1] = t[2] | (t[3] << 4);
        r[2] = t[4] | (t[5] << 4);
        r[3] = t[6] | (t[7] << 4);
        r += 4;
    }
#elif (KYBER_POLYCOMPRESSEDBYTES == 160)


    const float *codebook = codebook_d5;
    int num_floats=32;

    ClosestResult found;

    for (i = 0; i < KYBER_N / 8; i++) {
        for (j = 0; j < 8; j++) {
            // map to positive standard representatives
            found = findClosestInSortedFloatArray(codebook, num_floats, a->coeffs[8 * i + j]);
            t[j] = (int16_t)found.index;
        }

        r[0] = (t[0] >> 0) | (t[1] << 5);
        r[1] = (t[1] >> 3) | (t[2] << 2) | (t[3] << 7);
        r[2] = (t[3] >> 1) | (t[4] << 4);
        r[3] = (t[4] >> 4) | (t[5] << 1) | (t[6] << 6);
        r[4] = (t[6] >> 2) | (t[7] << 3);
        r += 5;
    }
#else
#error "KYBER_POLYCOMPRESSEDBYTES needs to be in {128, 160}"
#endif
}


void poly_decompress_mmse(poly* r, const uint8_t a[KYBER_POLYCOMPRESSEDBYTES])
{
    unsigned int i;

#if (KYBER_POLYCOMPRESSEDBYTES == 128)
    for (i = 0; i < KYBER_N / 2; i++) {
        //r->coeffs[2 * i + 0] = (((uint16_t)(a[0] & 15) * KYBER_Q) + 8) >> 4;
        //r->coeffs[2 * i + 1] = (((uint16_t)(a[0] >> 4)* KYBER_Q) + 8) >> 4;
        r->coeffs[2 * i + 0] = a[0] & 15;
        r->coeffs[2 * i + 1] = a[0] >> 4;

        a += 1;
    }
#elif (KYBER_POLYCOMPRESSEDBYTES == 160)
    unsigned int j;
    uint8_t t[8];
    for (i = 0; i < KYBER_N / 8; i++) {

        r->coeffs[8 * i + 0] = ((a[0] >> 0)) & 31;
        r->coeffs[8 * i + 1] = ((a[0] >> 5) | (a[1] << 3)) & 31;
        r->coeffs[8 * i + 2] = ((a[1] >> 2)) & 31;
        r->coeffs[8 * i + 3] = ((a[1] >> 7) | (a[2] << 1)) & 31;
        r->coeffs[8 * i + 4] = ((a[2] >> 4) | (a[3] << 4)) & 31;
        r->coeffs[8 * i + 5] = ((a[3] >> 1)) & 31;
        r->coeffs[8 * i + 6] = ((a[3] >> 6) | (a[4] << 2)) & 31;
        r->coeffs[8 * i + 7] = ((a[4] >> 3)) & 31;
        a += 5;


    }
#else
#error "KYBER_POLYCOMPRESSEDBYTES needs to be in {128, 160}"
#endif
}


void poly_index_toelement(poly* r, poly* e, poly* a)
{
    unsigned int i;

#if (KYBER_POLYCOMPRESSEDBYTES == 128)


    const float *codebook = codebook_d4;
    int num_floats=16;


        for (i = 0; i < KYBER_N; i++) {
            //r->coeffs[i] = round(codebook[a->coeffs[i]]);
            r->coeffs[i] = fast_roundf(codebook[a->coeffs[i]]);
            e->coeffs[i] = (int16_t)(2 * (codebook[a->coeffs[i]] - r->coeffs[i]));
         }

#elif (KYBER_POLYCOMPRESSEDBYTES == 160)

    const float *codebook = codebook_d5;
    int num_floats=32;


        for (i = 0; i < KYBER_N; i++) {

            r->coeffs[i] = fast_roundf(codebook[a->coeffs[i]]);
            e->coeffs[i] = (int16_t)(2 * (codebook[a->coeffs[i]] - r->coeffs[i]));
        }

#else
#error "KYBER_POLYVECCOMPRESSEDBYTES needs to be in {320*KYBER_K, 352*KYBER_K}"
#endif
}



void polyLD_index_toelement(poly_LD* r, poly_LD* e, poly_LD* a)
{
    unsigned int i, j;

#if (KYBER_POLYCOMPRESSEDBYTES == 128)


     const float *codebook = codebook_d4;
     int num_floats=16;

    for (j = 0; j < LATTICE_DIM; j++) {
        for (i = 0; i < KYBER_N; i++) {

            //r->vec[j].coeffs[i] = round(codebook[a->vec[j].coeffs[i]]);
            r->vec[j].coeffs[i] = fast_roundf(codebook[a->vec[j].coeffs[i]]);
            e->vec[j].coeffs[i] = (int16_t)(2 * (codebook[a->vec[j].coeffs[i]] - r->vec[j].coeffs[i]));
        }
    }
#elif (KYBER_POLYCOMPRESSEDBYTES == 160)


    const float *codebook = codebook_d5;
     int num_floats=32;

    for (j = 0; j < LATTICE_DIM; j++) {
        for (i = 0; i < KYBER_N; i++) {

            //r->vec[j].coeffs[i] = round(codebook[a->vec[j].coeffs[i]]);
            r->vec[j].coeffs[i] = fast_roundf(codebook[a->vec[j].coeffs[i]]);
            e->vec[j].coeffs[i] = (int16_t)(2 * (codebook[a->vec[j].coeffs[i]] - r->vec[j].coeffs[i]));
        }
    }
#else
#error "KYBER_POLYVECCOMPRESSEDBYTES needs to be in {320*KYBER_K, 352*KYBER_K}"
#endif
}


static void pack_ciphertext_mmse(uint8_t r[KYBER_INDCPA_BYTES], polyvec* b, poly* v)
{

#if (MMSE_Q_MODE == 'T')
        polyvec_compress_mmse(r, b);
        poly_compress_mmse(r + KYBER_POLYVECCOMPRESSEDBYTES, v);
#else
        polyvec_compress(r, b);
        poly_compress(r + KYBER_POLYVECCOMPRESSEDBYTES, v);
#endif
}

static void unpack_ciphertext_mmse(polyvec* b, poly* v, const uint8_t c[KYBER_INDCPA_BYTES])
{


#if (MMSE_Q_MODE == 'T')
	    polyvec_decompress_mmse(b, c);
    	poly_decompress_mmse(v, c + KYBER_POLYVECCOMPRESSEDBYTES);
#else
    	polyvec_decompress(b, c);
    	poly_decompress(v, c + KYBER_POLYVECCOMPRESSEDBYTES);
#endif
}




void indcpa_dec_mmse(uint8_t m[KYBER_INDCPA_MSGBYTES],
    const uint8_t c[KYBER_INDCPA_BYTES],
    const uint8_t sk[KYBER_INDCPA_SECRETKEYBYTES])
{
    polyvec b, skpv, index_b, b_e_mq;
    poly v, mp, e_qp;
    int16_t  t;
    unsigned int i, j;



    unpack_sk(&skpv, sk);

#if (MMSE_Q_MODE == 'T')
    poly index_v, v_e_mq;
    unpack_ciphertext_mmse(&index_b, &index_v, c);
    poly_index_toelement(&v, &v_e_mq, &index_v);
    polyvec_index_toelement(&b, &b_e_mq, &index_b);
#else
    unpack_ciphertext_mmse(&b, &v, c);
#endif


    polyvec_ntt(&b);
    polyvec_basemul_acc_montgomery(&mp, &skpv, &b);
    poly_invntt_tomont(&mp);


    for (i = 0; i < KYBER_N / 8; i++) {
        m[i] = 0;
        for (j = 0; j < 8; j++) {

#if (MMSE_Q_MODE == 'T')
        	 t = fast_roundf((float)(2 * v.coeffs[8 * i + j] + v_e_mq.coeffs[8 * i + j] - 2 * mp.coeffs[8 * i + j] ) * KYBER_Q_INV);
#else

        	 t = fast_roundf((float)(2 * v.coeffs[8 * i + j] - 2 * mp.coeffs[8 * i + j] ) * KYBER_Q_INV);


#endif

            m[i] |= (t & 1) << j;

        }
    }


}

void indcpa_enc_mmse(uint8_t c[KYBER_INDCPA_BYTES],
    const uint8_t m[KYBER_INDCPA_MSGBYTES],
    const uint8_t pk[KYBER_INDCPA_PUBLICKEYBYTES],
    const uint8_t coins[KYBER_SYMBYTES])
{
    unsigned int i,j;
    uint8_t seed[KYBER_SYMBYTES];
    uint8_t nonce = 0;
    polyvec sp, pkpv, ep, at[KYBER_K], b;
    poly v, k, epp;

    unpack_pk(&pkpv, seed, pk);
    poly_frommsg(&k, m);
    //gen_at(at, seed);
    gen_matrix(at, seed, 1);

    for (i = 0; i < KYBER_K; i++)
        poly_getnoise_eta1(sp.vec + i, coins, nonce++);
    for (i = 0; i < KYBER_K; i++)
        poly_getnoise_eta2(ep.vec + i, coins, nonce++);
    poly_getnoise_eta2(&epp, coins, nonce++);

    polyvec_ntt(&sp);

    // matrix-vector multiplication
    for (i = 0; i < KYBER_K; i++)
        polyvec_basemul_acc_montgomery(&b.vec[i], &at[i], &sp);

    polyvec_basemul_acc_montgomery(&v, &pkpv, &sp);

    polyvec_invntt_tomont(&b);
    poly_invntt_tomont(&v);

    polyvec_add(&b, &b, &ep);
    poly_add(&v, &v, &epp);
    poly_add(&v, &v, &k);
    polyvec_reduce(&b);
    poly_reduce(&v);

    pack_ciphertext_mmse(c, &b, &v);

}
///////////////////////////////////////////////////// Kyber PKE with MMSE Quantization END ////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////// Kyber KEM with MMSE Quantization END ////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////// P_KYBER PKE START ////////////////////////////////////////////////////////////////////////

static void pack_sk_P(uint8_t r[KYBER_INDCPA_SECRETKEYBYTES_LD], polyvec_LD* sk)
{
    unsigned int i, j;
    for (j = 0; j < LATTICE_DIM; j++) {
        for (i = 0; i < KYBER_K; i++) {
            poly_tobytes(r + i * KYBER_POLYBYTES + j* KYBER_INDCPA_SECRETKEYBYTES, &sk->pack[j].vec[i]);
        }
    }
}

static void unpack_sk_P(polyvec_LD* sk, const uint8_t packedsk[KYBER_INDCPA_SECRETKEYBYTES_LD])
{
    unsigned int i, j, k;

    for (j = 0; j < LATTICE_DIM; j++) {
        for (i = 0; i < KYBER_K; i++) {
            poly_frombytes(&sk->pack[j].vec[i], packedsk + i * KYBER_POLYBYTES + j * KYBER_INDCPA_SECRETKEYBYTES);
        }
    }
}




static void pack_pk_P(uint8_t r[KYBER_INDCPA_PUBLICKEYBYTES_LD],
    polyvec_LD *pk,
    const uint8_t seed[KYBER_SYMBYTES])
{
    size_t i;
    unsigned int j;
    for (j = 0; j < LATTICE_DIM; j++) {
        for (i = 0; i < KYBER_K; i++) {
            poly_tobytes(r + i * KYBER_POLYBYTES + j * KYBER_INDCPA_SECRETKEYBYTES, &pk->pack[j].vec[i]);
        }
    }

    for (i = 0; i < KYBER_SYMBYTES; i++)
        r[i + LATTICE_DIM*KYBER_POLYVECBYTES] = seed[i];
}


static void unpack_pk_P(polyvec_LD* pk,
    uint8_t seed[KYBER_SYMBYTES],
    const uint8_t packedpk[KYBER_INDCPA_PUBLICKEYBYTES_LD])
{
    size_t i;
    unsigned int j, k;
    //int16_t t;
    for (j = 0; j < LATTICE_DIM; j++) {
        for (i = 0; i < KYBER_K; i++) {
            poly_frombytes(&pk->pack[j].vec[i], packedpk + i * KYBER_POLYBYTES + j * KYBER_INDCPA_SECRETKEYBYTES);

        }
    }

    for (i = 0; i < KYBER_SYMBYTES; i++) {
        seed[i] = packedpk[i + LATTICE_DIM * KYBER_POLYVECBYTES];
    }
}



void indcpa_keypair_P(uint8_t pk[KYBER_INDCPA_PUBLICKEYBYTES_LD],
    uint8_t sk[KYBER_INDCPA_SECRETKEYBYTES_LD])
{
    unsigned int i, j;
    uint8_t buf[2 * KYBER_SYMBYTES];
    const uint8_t* publicseed = buf;
    const uint8_t* noiseseed = buf + KYBER_SYMBYTES;
    uint8_t nonce = 0;
    polyvec a[KYBER_K];
    polyvec_LD e, pkpv, skpv;

    esp_randombytes(buf, KYBER_SYMBYTES);
    hash_g(buf, buf, KYBER_SYMBYTES);

    //gen_a(a, publicseed);
    gen_matrix(a, publicseed, 0);



    for (j = 0; j < LATTICE_DIM; j++) {
        for (i = 0; i < KYBER_K; i++) {
            poly_getnoise_eta1(&skpv.pack[j].vec[i], noiseseed, nonce++);
            poly_getnoise_eta1(&e.pack[j].vec[i], noiseseed, nonce++);
        }
    }


    for (j = 0; j < LATTICE_DIM; j++) {
        polyvec_ntt(&skpv.pack[j]);
        polyvec_ntt(&e.pack[j]);

        // matrix-vector multiplication
        for (i = 0; i < KYBER_K; i++) {
            polyvec_basemul_acc_montgomery(&pkpv.pack[j].vec[i], &a[i], &skpv.pack[j]);
            poly_tomont(&pkpv.pack[j].vec[i]);
        }

        polyvec_add(&pkpv.pack[j], &pkpv.pack[j], &e.pack[j]);
        polyvec_reduce(&pkpv.pack[j]);
    }

    pack_sk_P(sk, &skpv);
    pack_pk_P(pk, &pkpv, publicseed);

}





static void pack_ciphertext_mmse_P(uint8_t r[KYBER_INDCPA_BYTES_LD], polyvec* b, poly_LD* v)
{
    unsigned int i;

#if (MMSE_Q_MODE == 'T')
    polyvec_compress_mmse(r, b);
    for (i = 0; i < LATTICE_DIM; i++) {
       poly_compress_mmse(r + KYBER_POLYVECCOMPRESSEDBYTES + i * KYBER_POLYCOMPRESSEDBYTES, v->vec + i);
    }
#else
    polyvec_compress(r, b);

    for (i = 0; i < LATTICE_DIM; i++) {
    	poly_compress(r + KYBER_POLYVECCOMPRESSEDBYTES + i * KYBER_POLYCOMPRESSEDBYTES, v->vec+i);
    }
#endif


}

static void unpack_ciphertext_mmse_P(polyvec* b, poly_LD* v, const uint8_t c[KYBER_INDCPA_BYTES_LD])
{
    unsigned int i;

#if (MMSE_Q_MODE == 'T')
    polyvec_decompress_mmse(b, c);
    for (i = 0; i < LATTICE_DIM; i++) {
        poly_decompress_mmse(v->vec + i, c + KYBER_POLYVECCOMPRESSEDBYTES + i * KYBER_POLYCOMPRESSEDBYTES);
    }
#else
    polyvec_decompress(b, c);
    for (i = 0; i < LATTICE_DIM; i++) {
        poly_decompress(v->vec + i, c + KYBER_POLYVECCOMPRESSEDBYTES + i * KYBER_POLYCOMPRESSEDBYTES);
    }
#endif


}





//Dn lattice decoder
void DnDecoder(int** LP, const float arr[]) {
    int* f = malloc(LATTICE_DIM * sizeof(int));
    int* g = malloc(LATTICE_DIM * sizeof(int));
    if (!f || !g) {
        free(f);
        free(g);
        *LP = NULL;
        return; // Allocation failed
    }

    int totalSum = 0;
    for (int i = 0; i < LATTICE_DIM; i++) {
        //f[i] = (int)roundf(arr[i]);
        f[i]=(int)(arr[i] + (arr[i] >= 0 ? 0.5f : -0.5f));

        g[i] = f[i];
        totalSum += f[i];
    }

    // Find the index with the largest absolute rounding difference
    int index = -1;
    float maxAbsoluteDiff = -1.0f;
    for (int i = 0; i < LATTICE_DIM; i++) {
        float diff = (float)f[i] - arr[i];
        float absoluteDiff = fabsf(diff);
        if (absoluteDiff > maxAbsoluteDiff) {
            maxAbsoluteDiff = absoluteDiff;
            index = i;
        }
    }

    if (index >= 0) {
        if (arr[index] > f[index]) {
            g[index]++;
        }
        else {
            g[index]--;
        }
    }

    // Ensure parity condition
    if ((totalSum & 1) == 0) {
        *LP = f;
        free(g);
    }
    else {
        *LP = g;
        free(f);
    }
}





uint8_t combineEleBits(const uint8_t ele[7]) {
    uint8_t result = 0;

    // Take 2 bits from ele[0], mask to 2 bits, shift to bits 7 and 6
    result |= (ele[0] & 0x03) << 6;

    // ele[1] -> bit 5
    result |= (ele[1] & 0x01) << 5;

    // ele[2] -> bit 4
    result |= (ele[2] & 0x01) << 4;

    // ele[3] -> bit 3
    result |= (ele[3] & 0x01) << 3;

    // ele[4] -> bit 2
    result |= (ele[4] & 0x01) << 2;

    // ele[5] -> bit 1
    result |= (ele[5] & 0x01) << 1;

    // ele[6] -> bit 0
    result |= (ele[6] & 0x01);

    return result;
}



void E8Decoder_S(uint8_t* tt, const float* y) {
    float numbers_shift[LATTICE_DIM];
    int* decodedVec1 = NULL;
    int* decodedVec2 = NULL;
    uint8_t ele[LATTICE_DIM - 1] = { 0 };

    // Decode original vector
    DnDecoder(&decodedVec1, y);

    // Shift input by 0.5
    for (int i = 0; i < LATTICE_DIM; i++) {
        numbers_shift[i] = y[i] - 0.5f;
    }

    // Decode shifted vector
    DnDecoder(&decodedVec2, numbers_shift);

    // Store shifted result (adding back 0.5)
    float shiftedWithOffset[LATTICE_DIM];
    for (int i = 0; i < LATTICE_DIM; i++) {
        shiftedWithOffset[i] = decodedVec2[i] + 0.5f;
    }

    // Compute sum for decision
    float tempSum = 0.0f;
    for (int i = 0; i < LATTICE_DIM; i++) {
        float diff = (float)decodedVec1[i] - shiftedWithOffset[i];
        float sum = (float)decodedVec1[i] + shiftedWithOffset[i] - 2.0f * y[i];
        tempSum += diff * sum;
    }

    // recover the information symbols for decoded E8 lattice point, use the inverse of corresponding SNF basis B_hat^{-1}
    if (tempSum < 0.0f) {

        ele[0] = (2 * decodedVec1[0]) & 3;
        ele[1] = (decodedVec1[0] - decodedVec1[1]) & 1;
        ele[2] = (2 * decodedVec1[0] - decodedVec1[1] - decodedVec1[2]) & 1;
        ele[3] = (3 * decodedVec1[0] - decodedVec1[1] - decodedVec1[2] - decodedVec1[3]) & 1;
        ele[4] = (4 * decodedVec1[0] - decodedVec1[1] - decodedVec1[2] - decodedVec1[3] - decodedVec1[4]) & 1;
        ele[5] = (5 * decodedVec1[0] - decodedVec1[1] - decodedVec1[2] - decodedVec1[3] - decodedVec1[4] - decodedVec1[5]) & 1;
        ele[6] = (-decodedVec1[0] + decodedVec1[7]) & 1;

    }
    else {

        ele[0] = fast_roundf(2 * shiftedWithOffset[0]) & 3;
        ele[1] = fast_roundf(shiftedWithOffset[0] - shiftedWithOffset[1]) & 1;
        ele[2] = fast_roundf(2 * shiftedWithOffset[0] - shiftedWithOffset[1] - shiftedWithOffset[2]) & 1;
        ele[3] = fast_roundf(3 * shiftedWithOffset[0] - shiftedWithOffset[1] - shiftedWithOffset[2] - shiftedWithOffset[3]) & 1;
        ele[4] = fast_roundf(4 * shiftedWithOffset[0] - shiftedWithOffset[1] - shiftedWithOffset[2] - shiftedWithOffset[3] - shiftedWithOffset[4]) & 1;
        ele[5] = fast_roundf(5 * shiftedWithOffset[0] - shiftedWithOffset[1] - shiftedWithOffset[2] - shiftedWithOffset[3] - shiftedWithOffset[4] - shiftedWithOffset[5]) & 1;
        ele[6] = fast_roundf(-shiftedWithOffset[0] + shiftedWithOffset[7]) & 1;

    }

    // Output result
    *tt = combineEleBits(ele);

    // Clean up
    free(decodedVec1);
    free(decodedVec2);
}





void byte_to2E8_S(uint8_t value, uint8_t E8[LATTICE_DIM]) {
    uint8_t elements[LATTICE_DIM - 1];

    // Extract bits from value into elements[]
    for (int i = 0; i < 6; i++) {
        elements[6 - i] = (value >> i) & 1; // MSB at lower index
    }
    elements[0] = (value >> 6) & 0x03; // top 2 bits

    // Compute E8 coordinates, using the SNF basis B_hat
    E8[0] = elements[0];
    E8[1] = (elements[0] - 2 * elements[1]) & 3;
    E8[2] = (elements[0] + 2 * elements[1] - 2 * elements[2]) & 3;
    E8[3] = (elements[0] + 2 * elements[2] - 2 * elements[3]) & 3;
    E8[4] = (elements[0] + 2 * elements[3] - 2 * elements[4]) & 3;
    E8[5] = (elements[0] + 2 * elements[4] - 2 * elements[5]) & 3;
    E8[6] = (elements[0] + 2 * elements[5] + 14 * elements[6]) & 3;
    E8[7] = (elements[0] + 2 * elements[6]) & 3;
}






static void indcpa_enc_mmse_P(uint8_t c[KYBER_INDCPA_BYTES_LD],
    const uint8_t m[KYBER_INDCPA_MSGBYTES_LD],
    const uint8_t pk[KYBER_INDCPA_PUBLICKEYBYTES_LD],
    const uint8_t coins[KYBER_SYMBYTES], const uint8_t flag)
{

    uint8_t seed[KYBER_SYMBYTES];
    uint8_t nonce = 0;
    polyvec sp, ep, at[KYBER_K], b;
    poly_LD v, k, epp;
    polyvec_LD pkpv;

    uint8_t E8[LATTICE_DIM] = { 0 };

    unsigned int i,j;

    unpack_pk_P(&pkpv, seed, pk);

    if (flag == 0) {
        for (i = 0; i < LATTICE_DIM; i++) {
            poly_frommsg(&k.vec[i], m + i * KYBER_SYMBYTES);

        }
    } else{
        for (j = 0; j < KYBER_N; j++) {
            byte_to2E8_S(m[j], E8);
            for (i = 0; i < LATTICE_DIM; i++) {
                k.vec[i].coeffs[j] = E8[i] * 832;

            }
        }
    }



    ///A^T
    gen_matrix(at, seed, 1);



    for (i = 0; i < KYBER_K; i++) {
        poly_getnoise_eta1(sp.vec + i, coins, nonce++);
    }
    for (i = 0; i < KYBER_K; i++) {
        poly_getnoise_eta2(ep.vec + i, coins, nonce++);
    }

    polyvec_ntt(&sp);


    // matrix-vector multiplication
    for (i = 0; i < KYBER_K; i++) {
        polyvec_basemul_acc_montgomery(&b.vec[i], &at[i], &sp);
    }

    polyvec_invntt_tomont(&b);
    polyvec_add(&b, &b, &ep);
    polyvec_reduce(&b);


    for (i = 0; i < LATTICE_DIM; i++) {
        poly_getnoise_eta2(&epp.vec[i], coins, nonce++);
    }


    for (i = 0; i < LATTICE_DIM; i++) {
        polyvec_basemul_acc_montgomery(&v.vec[i], &pkpv.pack[i], &sp);
        poly_invntt_tomont(&v.vec[i]);
        poly_add(&v.vec[i], &v.vec[i], &epp.vec[i]);
        poly_add(&v.vec[i], &v.vec[i], &k.vec[i]);
        poly_reduce(&v.vec[i]);
    }


    pack_ciphertext_mmse_P(c, &b, &v);


}


static void indcpa_dec_mmse_P(uint8_t m[KYBER_INDCPA_MSGBYTES_LD],
    const uint8_t c[KYBER_INDCPA_BYTES_LD],
    const uint8_t sk[KYBER_INDCPA_SECRETKEYBYTES_LD], const uint8_t flag)
{
    polyvec b, index_b, b_e_mq;
    int16_t  t;
    unsigned int i, j, z;

    polyvec_LD skpv;
    poly_LD mp, e_qp, v;

    float E8_f[LATTICE_DIM] = { 0 };
    float q_inv= 1.0f / 3328.0f;



#if (MMSE_Q_MODE == 'T')
        poly_LD index_v, v_e_mq;
        unpack_ciphertext_mmse_P(&index_b, &index_v, c);
        polyLD_index_toelement(&v, &v_e_mq, &index_v);
        polyvec_index_toelement(&b, &b_e_mq, &index_b);
#else
        unpack_ciphertext_mmse_P(&b, &v, c);
#endif



    unpack_sk_P(&skpv, sk);


    ////////////////////////////////////////////


    polyvec_ntt(&b);
    for (i = 0; i < LATTICE_DIM; i++) {
        polyvec_basemul_acc_montgomery(&mp.vec[i], &skpv.pack[i], &b);
        poly_invntt_tomont(&mp.vec[i]);
    }



    if (flag == 0) {
    	//uncoded decoding
        for (z = 0; z < LATTICE_DIM; z++) {
            for (i = 0; i < KYBER_N / 8; i++) {
                m[z * KYBER_SYMBYTES + i] = 0;
                for (j = 0; j < 8; j++) {

#if (MMSE_Q_MODE == 'T')

                	t = fast_roundf((float)(2 * v.vec[z].coeffs[8 * i + j] + v_e_mq.vec[z].coeffs[8 * i + j] - 2 * mp.vec[z].coeffs[8 * i + j]) * KYBER_Q_INV);
#else

                	t = fast_roundf((float)(2 * v.vec[z].coeffs[8 * i + j]  - 2 * mp.vec[z].coeffs[8 * i + j]) * KYBER_Q_INV);
#endif

                    m[z * KYBER_SYMBYTES + i] |= (t & 1) << j;
                }
            }
        }
    }
    else {
        //E8 decoding
        for (j = 0; j < KYBER_N; j++) {
            for (i = 0; i < LATTICE_DIM; i++) {


#if (MMSE_Q_MODE == 'T')

            	E8_f[i] = (2 * v.vec[i].coeffs[j] + v_e_mq.vec[i].coeffs[j] - 2 * mp.vec[i].coeffs[j]) * q_inv;
#else

            	E8_f[i] = (2 * v.vec[i].coeffs[j] - 2 * mp.vec[i].coeffs[j]) * q_inv;
#endif
            }
            E8Decoder_S(&m[j], E8_f);
        }

    }



}
///////////////////////////////////////////////////// P_KYBER PKE END ////////////////////////////////////////////////////////////////////////

int crypto_kem_keypair_P(uint8_t* pk,
    uint8_t* sk)
{
    size_t i;
    indcpa_keypair_P(pk, sk);
    //for (i = 0; i < KYBER_INDCPA_PUBLICKEYBYTES_LD; i++)
      //  sk[i + KYBER_INDCPA_SECRETKEYBYTES_LD] = pk[i];
    //hash_h(sk + KYBER_SECRETKEYBYTES_LD - 2 * KYBER_SYMBYTES, pk, KYBER_PUBLICKEYBYTES_LD);
    hash_h(sk + KYBER_INDCPA_SECRETKEYBYTES_LD, pk, KYBER_PUBLICKEYBYTES_LD);
    esp_randombytes(sk + KYBER_INDCPA_SECRETKEYBYTES_LD + KYBER_SYMBYTES, KYBER_SYMBYTES);
    //sk size KYBER_INDCPA_SECRETKEYBYTES_LD+32+32

    /* Value z for pseudo-random output on reject */
    //esp_randombytes(sk + KYBER_SECRETKEYBYTES_LD - KYBER_SYMBYTES, KYBER_SYMBYTES);
    return 0;
}


int crypto_kem_enc_P(uint8_t* ct,
    uint8_t* ss,
    const uint8_t* pk, const uint8_t flag)
{

    unsigned int i, j;

    uint8_t buf[KYBER_SYMBYTES_LD + KYBER_SYMBYTES];
    /* Will contain key, coins */
    uint8_t kr[2 * KYBER_SYMBYTES];

    esp_randombytes(buf, KYBER_SYMBYTES_LD);
    /* Don't release system RNG output */
    for (i = 0; i < LATTICE_DIM; i++) {
        hash_h(buf + i * KYBER_SYMBYTES, buf + i * KYBER_SYMBYTES, KYBER_SYMBYTES);
    }


    /* Multitarget countermeasure for coins + contributory KEM */
    hash_h(buf + KYBER_SYMBYTES_LD, pk, KYBER_PUBLICKEYBYTES_LD);
    hash_g(kr, buf, KYBER_SYMBYTES_LD + KYBER_SYMBYTES);

    /* coins are in kr+KYBER_SYMBYTES */

    /*
    printf("encoded buf \n");
    printUint8Array(buf, KYBER_INDCPA_MSGBYTES_LD + KYBER_SYMBYTES);

    printf("\n");
    */

    indcpa_enc_mmse_P(ct, buf, pk, kr + KYBER_SYMBYTES, flag);


    /* overwrite coins in kr with H(c) */
    /* hash concatenation of pre-k and H(c) to k */

    for (i = 0; i < LATTICE_DIM; i++) {
        hash_h(kr + KYBER_SYMBYTES, ct + i * KYBER_POLYCOMPRESSEDBYTES, KYBER_CIPHERTEXTBYTES_LD - i * KYBER_POLYCOMPRESSEDBYTES);
        kdf(ss + i * KYBER_SYMBYTES, kr, 2 * KYBER_SYMBYTES);
    }


    return 0;
}



int crypto_kem_dec_P(uint8_t* ss,
    const uint8_t* ct,
    const uint8_t* sk, const uint8_t* pk, const uint8_t flag)
{
    size_t i;
    int fail;
    uint8_t buf[KYBER_INDCPA_MSGBYTES_LD + KYBER_SYMBYTES];
    /* Will contain key, coins */

    uint8_t kr[2 * KYBER_SYMBYTES];

    uint8_t cmp[KYBER_CIPHERTEXTBYTES_LD];

    //const uint8_t* pk = sk + KYBER_INDCPA_SECRETKEYBYTES_LD;

    indcpa_dec_mmse_P(buf, ct, sk, flag);

   /* printf("decoded buf \n");
    printUint8Array(buf, KYBER_INDCPA_MSGBYTES_LD + KYBER_SYMBYTES);

    printf("\n");
*/

    /* Multitarget countermeasure for coins + contributory KEM */
    for (i = 0; i < KYBER_SYMBYTES; i++)
        //buf[KYBER_SYMBYTES_LD + i] = sk[KYBER_SECRETKEYBYTES_LD - 2 * KYBER_SYMBYTES + i];
    	buf[KYBER_SYMBYTES_LD + i] = sk[KYBER_INDCPA_SECRETKEYBYTES_LD + i];


    hash_g(kr, buf, KYBER_SYMBYTES_LD + KYBER_SYMBYTES);

    /* coins are in kr+KYBER_SYMBYTES */
    //indcpa_enc(cmp, buf, pk, kr + KYBER_SYMBYTES);
    indcpa_enc_mmse_P(cmp, buf, pk, kr + KYBER_SYMBYTES, flag);

    fail = verify(ct, cmp, KYBER_CIPHERTEXTBYTES_LD);


    /* overwrite coins in kr with H(c) */
    //hash_h(kr+KYBER_SYMBYTES, ct, KYBER_CIPHERTEXTBYTES);

    /* Overwrite pre-k with z on re-encryption failure */
    //cmov(kr, sk + KYBER_SECRETKEYBYTES_LD - KYBER_SYMBYTES, KYBER_SYMBYTES, fail);
    cmov(kr, sk + KYBER_INDCPA_SECRETKEYBYTES_LD + KYBER_SYMBYTES, KYBER_SYMBYTES, fail);

    /* hash concatenation of pre-k and H(c) to k */


    for (i = 0; i < LATTICE_DIM; i++) {
        //hash_h(kr + KYBER_SYMBYTES, ct + KYBER_POLYVECCOMPRESSEDBYTES + i * KYBER_POLYCOMPRESSEDBYTES, KYBER_CIPHERTEXTBYTES + i * KYBER_POLYCOMPRESSEDBYTES);
        hash_h(kr + KYBER_SYMBYTES, ct + i * KYBER_POLYCOMPRESSEDBYTES, KYBER_CIPHERTEXTBYTES_LD - i * KYBER_POLYCOMPRESSEDBYTES);
        kdf(ss + i * KYBER_SYMBYTES, kr, 2 * KYBER_SYMBYTES);
    }



    return 0;
}

///////////////////////////////////////////////////// P_KYBER KEM  END ////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////// P_1 Kyber KEM with E8 coding and MMSE Quantization Start ////////////////////////////////////////////////////////////////////////

void indcpa_dec_E8(uint8_t m[KYBER_INDCPA_MSGBYTES],
    const uint8_t c[KYBER_INDCPA_BYTES],
    const uint8_t sk[KYBER_INDCPA_SECRETKEYBYTES])
{
    polyvec b, skpv, index_b, b_e_mq;
    poly v, mp, e_qp;
    int16_t  t;
    unsigned int i, j;
    float E8_f[LATTICE_DIM] = { 0 };
    float q_inv= 1.0f / 3328.0f;



    unpack_sk(&skpv, sk);

#if (MMSE_Q_MODE == 'T')
    poly index_v, v_e_mq;
    unpack_ciphertext_mmse(&index_b, &index_v, c);
    poly_index_toelement(&v, &v_e_mq, &index_v);
    polyvec_index_toelement(&b, &b_e_mq, &index_b);
#else
    unpack_ciphertext_mmse(&b, &v, c);
#endif


    polyvec_ntt(&b);
    polyvec_basemul_acc_montgomery(&mp, &skpv, &b);
    poly_invntt_tomont(&mp);


    for (i = 0; i < KYBER_N / 8; i++) {
        m[i] = 0;
        for (j = 0; j < 8; j++) {

#if (MMSE_Q_MODE == 'T')
        	// t = fast_roundf((float)(2 * v.coeffs[8 * i + j] + v_e_mq.coeffs[8 * i + j] - 2 * mp.coeffs[8 * i + j] ) * KYBER_Q_INV);
        	E8_f[j] = (2 * v.coeffs[8 * i + j] + v_e_mq.coeffs[8 * i + j]- 2 * mp.coeffs[8 * i + j]) * q_inv;
#else

        	 //t = fast_roundf((float)(2 * v.coeffs[8 * i + j] - 2 * mp.coeffs[8 * i + j] ) * KYBER_Q_INV);
        	 E8_f[j] = (2 * v.coeffs[8 * i + j] - 2 * mp.coeffs[8 * i + j]) * q_inv;

#endif

            //m[i] |= (t & 1) << j;

        }
        E8Decoder_S(&m[i], E8_f);
    }


}

void indcpa_enc_E8(uint8_t c[KYBER_INDCPA_BYTES],
    const uint8_t m[KYBER_INDCPA_MSGBYTES],
    const uint8_t pk[KYBER_INDCPA_PUBLICKEYBYTES],
    const uint8_t coins[KYBER_SYMBYTES])
{
    unsigned int i,j;
    uint8_t seed[KYBER_SYMBYTES];
    uint8_t nonce = 0;
    polyvec sp, pkpv, ep, at[KYBER_K], b;
    poly v, k, epp;

    unpack_pk(&pkpv, seed, pk);


    //poly_frommsg(&k, m);


    uint8_t E8[LATTICE_DIM] = { 0 };

    for (j = 0; j < KYBER_INDCPA_MSGBYTES; j++) {
    	byte_to2E8_S(m[j], E8);
    	for (i = 0; i < LATTICE_DIM; i++) {
    		k.coeffs[8*j+i] = E8[i] * 832;
    	}
    }


    //gen_at(at, seed);
    gen_matrix(at, seed, 1);

    for (i = 0; i < KYBER_K; i++)
        poly_getnoise_eta1(sp.vec + i, coins, nonce++);
    for (i = 0; i < KYBER_K; i++)
        poly_getnoise_eta2(ep.vec + i, coins, nonce++);
    poly_getnoise_eta2(&epp, coins, nonce++);

    polyvec_ntt(&sp);

    // matrix-vector multiplication
    for (i = 0; i < KYBER_K; i++)
        polyvec_basemul_acc_montgomery(&b.vec[i], &at[i], &sp);

    polyvec_basemul_acc_montgomery(&v, &pkpv, &sp);

    polyvec_invntt_tomont(&b);
    poly_invntt_tomont(&v);

    polyvec_add(&b, &b, &ep);
    poly_add(&v, &v, &epp);
    poly_add(&v, &v, &k);
    polyvec_reduce(&b);
    poly_reduce(&v);

    pack_ciphertext_mmse(c, &b, &v);

}





int crypto_kem_enc_mmse(uint8_t* ct,
    uint8_t* ss,
    const uint8_t* pk, const uint8_t flag)
{
    uint8_t buf[2 * KYBER_SYMBYTES];
    /* Will contain key, coins */
    uint8_t kr[2 * KYBER_SYMBYTES];

    esp_randombytes(buf, KYBER_SYMBYTES);
    /* Don't release system RNG output */
    hash_h(buf, buf, KYBER_SYMBYTES);

    /* Multitarget countermeasure for coins + contributory KEM */
    hash_h(buf + KYBER_SYMBYTES, pk, KYBER_PUBLICKEYBYTES);
    hash_g(kr, buf, 2 * KYBER_SYMBYTES);

    /* coins are in kr+KYBER_SYMBYTES */
    if (flag ==0) {
    	indcpa_enc_mmse(ct, buf, pk, kr + KYBER_SYMBYTES);
    }else {
    	indcpa_enc_E8(ct, buf, pk, kr + KYBER_SYMBYTES);
    }

    /* overwrite coins in kr with H(c) */
    hash_h(kr + KYBER_SYMBYTES, ct, KYBER_CIPHERTEXTBYTES);
    /* hash concatenation of pre-k and H(c) to k */
    kdf(ss, kr, 2 * KYBER_SYMBYTES);
    return 0;
}


int crypto_kem_dec_mmse(uint8_t* ss,
    const uint8_t* ct,
    const uint8_t* sk, const uint8_t flag)
{
    size_t i;
    int fail;
    uint8_t buf[2 * KYBER_SYMBYTES];
    /* Will contain key, coins */
    uint8_t kr[2 * KYBER_SYMBYTES];
    uint8_t cmp[KYBER_CIPHERTEXTBYTES];
    const uint8_t* pk = sk + KYBER_INDCPA_SECRETKEYBYTES;

    //indcpa_dec_mmse(buf, ct, sk);
    if (flag ==0) {
    	indcpa_dec_mmse(buf, ct, sk);
    } else {
    	indcpa_dec_E8(buf, ct, sk);
    }

    /* Multitarget countermeasure for coins + contributory KEM */
    for (i = 0; i < KYBER_SYMBYTES; i++)
        buf[KYBER_SYMBYTES + i] = sk[KYBER_SECRETKEYBYTES - 2 * KYBER_SYMBYTES + i];
    hash_g(kr, buf, 2 * KYBER_SYMBYTES);

    /* coins are in kr+KYBER_SYMBYTES */
    //indcpa_enc_mmse(cmp, buf, pk, kr + KYBER_SYMBYTES);
    if (flag ==0) {indcpa_enc_mmse(cmp, buf, pk, kr + KYBER_SYMBYTES);

    }else {
    	indcpa_enc_E8(cmp, buf, pk, kr + KYBER_SYMBYTES);
    }

    //fail = verify(ct, cmp, KYBER_CIPHERTEXTBYTES);
    fail = verify(ct, cmp, KYBER_CIPHERTEXTBYTES);

    /* overwrite coins in kr with H(c) */
    hash_h(kr + KYBER_SYMBYTES, ct, KYBER_CIPHERTEXTBYTES);

    /* Overwrite pre-k with z on re-encryption failure */
    cmov(kr, sk + KYBER_SECRETKEYBYTES - KYBER_SYMBYTES, KYBER_SYMBYTES, fail);

    /* hash concatenation of pre-k and H(c) to k */
    kdf(ss, kr, 2 * KYBER_SYMBYTES);
    return 0;
}

///////////////////////////////////////////////////// P_1 Kyber KEM with E8 coding and MMSE Quantization end ////////////////////////////////////////////////////////////////////////

int main() {
    /* Initialization and definition*/
	//Setup cycle count
	*SCB_DEMCR |= 0x01000000;
	*DWT_LAR = 0xC5ACCE55; // enable access
	*DWT_CYCCNT = 0; // reset the counter


    printf("-------------------------------------------------------------------- \n");
    if (KYBER_K == 2) {
        printf("Test P_1-Kyber using the parameters of KYBER512 \n");
    }
    else if (KYBER_K == 3) {
        printf("Test P_1-Kyber using the parameters of KYBER768 \n");

    }
    else {
        printf("Test P_1-Kyber using the parameters of KYBER1024\n");
    }

    if (MMSE_Q_MODE == 'T') {
            printf("Quantization method: MMSE quantization \n");
        }
        else {
            printf("Quantization method: original Kyber quantization\n");

        }

 /*  if (Compress_More =='T') {
        printf("using smaller compression parameter to reduce ciphertext size: e.g., d_u= 10 and d_v = 4 for KYBER1024 \n");
    }*/

    printf("*In params.h, set KYBER_K to select the target variant \n");
    //printf("**KYBER512: KYBER_K = 2; KYBER768: KYBER_K == 3, KYBER1024: KYBER_K == 4 \n");
    printf("*In params.h, set MMSE_Q_MODE = 'T' to enable MMSE quantization, or set MMSE_Q_MODE = 'F' to use the original Kyber quantization. \n");
    printf("*In params.h, set Compress_More ='T' for smaller (d_u, d_v)  \n");
    printf("*set encoder_flag = 1 enable E8 coded scheme \n");


    printf("-------------------------------------------------------------------- \n");


	   uint8_t pk[CRYPTO_PUBLICKEYBYTES];
	   uint8_t sk[CRYPTO_SECRETKEYBYTES];
	   uint8_t ct[KYBER_CIPHERTEXTBYTES];
	   uint8_t key_a[CRYPTO_BYTES];
	   uint8_t key_b[CRYPTO_BYTES];


	   unsigned int t1, t2, numCycle1;

	   /*
	    printf("-------------------------------------------------------------------- \n");
	    printf("Test 0: Run the original Kyber KEM 1 times to exchange 1 AES Keys \n");
	    //printf("*Run (KeyGen, Enc, Dec) a single time and scale each cycle count by 8\n");
	    printf("-------------------------------------------------------------------- \n");






	*DWT_CONTROL |= 1; // enable the counter
	t1 = *DWT_CYCCNT;

    crypto_kem_keypair(pk, sk);

	t2 = *DWT_CYCCNT;
	*DWT_CONTROL |= 0; // close the counter
	numCycle1 = t2 - t1;
	printf("clock cycles for 1 call of KeyGen: %u \n",
				numCycle1);                 // Display the difference

	*DWT_CONTROL |= 1; // enable the counter
	t1 = *DWT_CYCCNT;

	crypto_kem_enc(ct, key_b, pk);

	t2 = *DWT_CYCCNT;
	*DWT_CONTROL |= 0; // close the counter
	numCycle1 = t2 - t1;
	printf("clock cycles for 1 calls of Enc: %u \n",
					numCycle1);

	*DWT_CONTROL |= 1; // enable the counter
	t1 = *DWT_CYCCNT;

	crypto_kem_dec(key_a, ct, sk);

	t2 = *DWT_CYCCNT;
	*DWT_CONTROL |= 0; // close the counter
	numCycle1 = t2 - t1;
	printf("clock cycles for 1 call of Dec: %u \n",
					numCycle1);

	printf("\n");
	printf("public key size: %u bytes \n",
			CRYPTO_PUBLICKEYBYTES);
	printf("ciphertext size: %u bytes \n",
			KYBER_CIPHERTEXTBYTES);
*/


 /*   printf("\n");
    printf("secret message: \n");
    printUint8Array(key_b, 32);

    printf("decrypted secret message: \n");
    printUint8Array(key_a, 32);
    printf("\n");
*/
	//printf("clock cycles for 8 calls of KYBER KEM: %u \n", numCycle1*8);                 // Display the difference

	

    printf("-------------------------------------------------------------------- \n");
   // printf("Test: Kyber KEM with E8 encoding/decoding and original Kyber quantization or MMSE quantization\n");
    //printf("*Run (KeyGen, Enc, Dec) a single time and scale each cycle count by 8\n");
   // printf("*In params.h, set MMSE_Q_MODE = 'T' to enable MMSE quantization. \n");
    //printf("*set encoder_flag = 1 for E8 coded scheme \n");
    //printf("**set Compress_More ='T' for smaller (d_u, d_v)  \n");

    printf("-------------------------------------------------------------------- \n");

    uint8_t encoder_flag;

    encoder_flag=1;


*DWT_CONTROL |= 1; // enable the counter
t1 = *DWT_CYCCNT;

crypto_kem_keypair(pk, sk);

t2 = *DWT_CYCCNT;
*DWT_CONTROL |= 0; // close the counter
numCycle1 = t2 - t1;
printf("clock cycles for 1 call of KeyGen: %u \n",
			numCycle1);                 // Display the difference

*DWT_CONTROL |= 1; // enable the counter
t1 = *DWT_CYCCNT;

crypto_kem_enc_mmse(ct, key_b, pk, encoder_flag);

t2 = *DWT_CYCCNT;
*DWT_CONTROL |= 0; // close the counter
numCycle1 = t2 - t1;
printf("clock cycles for 1 call of Enc: %u \n",
				numCycle1);

*DWT_CONTROL |= 1; // enable the counter
t1 = *DWT_CYCCNT;

crypto_kem_dec_mmse(key_a, ct, sk, encoder_flag);

t2 = *DWT_CYCCNT;
*DWT_CONTROL |= 0; // close the counter
numCycle1 = t2 - t1;
printf("clock cycles for 1 call of Dec: %u \n",
				numCycle1);

printf("\n");
printf("public key size: %u bytes \n",
		CRYPTO_PUBLICKEYBYTES);
printf("ciphertext size: %u bytes \n",
		KYBER_CIPHERTEXTBYTES);


   printf("\n");
   printf("secret message: \n");
   printUint8Array(key_b, 32);

   printf("decrypted secret message: \n");
   printUint8Array(key_a, 32);
   printf("\n");












//////////////////////////////////////////////////////////////////////////////////////////


	return EXIT_SUCCESS;
}
